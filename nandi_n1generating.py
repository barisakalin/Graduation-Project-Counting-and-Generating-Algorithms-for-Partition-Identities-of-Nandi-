# -*- coding: utf-8 -*-
"""nandi_n1generating.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dfHwW9Tknv7_BUQjOxhebdLA3L8H9cO7
"""

n = int(input("Integer: "))
m = 1
sum = 2
increment = 2
l = 1
min_array = [2]
while sum <= n:
  min_array.append(sum)
  if l == 1:
    l = 0
    sum += increment
    increment += 4
  else:
    l += 1
    sum += increment
  if sum > n:
    break
  else:
    m += 1

n1_partitions = [[[]for j in range(n+1)] for k in range(m+1)]
n1_partitions_bool = [[[]for j in range(n+1)] for k in range(m+1)]

for i in range(2,n+1):
  n1_partitions[1][i].append([i])
  n1_partitions_bool[1][i].append([True])

for i in range(1,m):
  for j in range(min_array[i],n+1):
    for x in range(0,len(n1_partitions[i][j])):
      curr_num = n1_partitions[i][j][x][0]
      while curr_num + j <= n:
        #print(i,j,curr_num)
        if curr_num == n1_partitions[i][j][x][0] + 1: #[1]
          curr_num += 1
          continue
        elif i > 1 and curr_num == n1_partitions[i][j][x][0] and n1_partitions[i][j][x][0] == n1_partitions[i][j][x][1]: #[0,0]
          curr_num += 1
          continue
        elif i > 1 and curr_num == n1_partitions[i][j][x][0] and n1_partitions[i][j][x][0] == n1_partitions[i][j][x][1] + 2: #[0,2]
          curr_num += 1
          continue
        elif i > 1 and curr_num == n1_partitions[i][j][x][0] + 2 and n1_partitions[i][j][x][0] == n1_partitions[i][j][x][1]: #[2,0]
          curr_num += 1
          continue
        elif i > 1 and curr_num == n1_partitions[i][j][x][0] and n1_partitions[i][j][x][0] == n1_partitions[i][j][x][1] + 3: #[0,3]
          curr_num += 1
          continue
        elif i > 1 and curr_num == n1_partitions[i][j][x][0] + 3 and n1_partitions[i][j][x][0] == n1_partitions[i][j][x][1] and (curr_num + n1_partitions[i][j][x][0] + n1_partitions[i][j][x][1]) % 2 == 1: #[3,0] odd case
          curr_num += 1
          continue
        elif i > 1 and curr_num == n1_partitions[i][j][x][0] + 3 and n1_partitions[i][j][x][0] == n1_partitions[i][j][x][1] and (curr_num + n1_partitions[i][j][x][0] + n1_partitions[i][j][x][1]) % 2 == 0: #[3,0] even case
          new_partition = [curr_num]
          new_partition.extend(n1_partitions[i][j][x])
          n1_partitions[i+1][j+curr_num].append(new_partition)
          new_bool_partition = [False]
          n1_partitions_bool[i+1][j+curr_num].append(new_bool_partition)
          curr_num += 1
        elif i > 1 and curr_num == n1_partitions[i][j][x][0] and n1_partitions[i][j][x][0] == n1_partitions[i][j][x][1] + 4 and (curr_num + n1_partitions[i][j][x][0] + n1_partitions[i][j][x][1]) % 2 == 1: #[0,4]
          curr_num += 1
          continue
        elif i > 1 and curr_num == n1_partitions[i][j][x][0] + 4 and n1_partitions[i][j][x][0] == n1_partitions[i][j][x][1] and (curr_num + n1_partitions[i][j][x][0] + n1_partitions[i][j][x][1]) % 2 == 1: #[4,0]
          curr_num += 1
          continue
        elif n1_partitions_bool[i][j][x] == [False] and curr_num == n1_partitions[i][j][x][0] + 2: #[3,0]'a 2 eklenmesi durumu
          new_partition = [curr_num]
          new_partition.extend(n1_partitions[i][j][x])
          n1_partitions[i+1][j+curr_num].append(new_partition)
          new_bool_partition = [False]
          n1_partitions_bool[i+1][j+curr_num].append(new_bool_partition)
          curr_num += 1
        elif n1_partitions_bool[i][j][x] == [False] and curr_num == n1_partitions[i][j][x][0] + 3: #[3,0]'a 3 eklenmesi durumu
          curr_num += 1
          continue
        else:
          new_partition = [curr_num]
          new_partition.extend(n1_partitions[i][j][x])
          n1_partitions[i+1][j+curr_num].append(new_partition)
          new_bool_partition = [True]
          n1_partitions_bool[i+1][j+curr_num].append(new_bool_partition)
          curr_num += 1

count = 0
for a in range(1,m+1):
  for part in n1_partitions[a][n]:
    print(part)
    count += 1

print("Count:", count)

#print(n1_partitions)